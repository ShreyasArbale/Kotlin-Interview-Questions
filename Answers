1. Fundamentals & Core Concepts

Basic Kotlin Concepts

1) What is Kotlin?
Kotlin is a modern, statically typed programming language that runs on the JVM and is officially supported by Google for Android development. It is concise, safe, and fully interoperable with Java.

2) Who developed Kotlin?
Kotlin was developed by JetBrains, the company behind IntelliJ IDEA and Android Studio.

3) What are the key advantages and features of Kotlin compared to Java?
Concise code (less boilerplate)
Null safety (reduces NullPointerException)
Full Java interoperability
Smart casts
Extension functions
Data classes
Coroutines for asynchronous programming
Improved readability and maintainability

4) What is the difference between Java and Kotlin?
Feature	Java	Kotlin
Null Safety	No	Yes
Boilerplate Code	More	Less
Data Classes	Manual	Built-in
Coroutines	Not native	Built-in
Extension Functions	No	Yes
Checked Exceptions	Yes	No
Functional Support	Limited	Strong

5) What is Kotlin's primary target platform?
Kotlin‚Äôs primary target platform is the Java Virtual Machine (JVM), but it also supports:
Android
Kotlin/JS (JavaScript)
Kotlin/Native (iOS, desktop, embedded)

6) How does Kotlin-Java interoperability work?
Kotlin can call Java code directly
Java can call Kotlin code
Kotlin compiles to JVM bytecode
Existing Java libraries and frameworks work seamlessly in Kotlin
No need to rewrite Java code when migrating

7) What programming paradigms does Kotlin support?
Kotlin supports:
Object-Oriented Programming (OOP)
Functional Programming
Procedural Programming
Declarative style (especially with Jetpack Compose)

8) What serves as the entry point for a Kotlin program?
The entry point is the main() function:
fun main() {
    println("Hello, Kotlin")
}

9) What are some basic syntax rules in Kotlin?
Semicolons are optional
fun keyword is used for functions
val for immutable variables, var for mutable
Type inference is supported
Classes are declared using class
String templates use $variable
Example:
val name = "Shreyas"
fun greet() {
    println("Hello $name")
}

10) What are some common libraries and frameworks used with Kotlin (beyond standard library)?
Android Jetpack (ViewModel, LiveData, Room)
Jetpack Compose
Kotlin Coroutines
Retrofit
Ktor
Firebase
Dagger / Hilt
Glide / Coil
JUnit / MockK

Object-Oriented Programming (OOP) Fundamentals

1) What is Object-Oriented Programming (OOP)?
Object-Oriented Programming is a programming paradigm that organizes software using objects, which represent real-world entities. Each object contains data (properties) and behavior (methods).

2) Explain the core concept of OOP.
The core concept of OOP is modeling real-world problems using objects that:
Combine data + behavior
Interact with each other
Promote reusability, scalability, and maintainability

3) How does OOP differ from procedural programming?
Aspect	Procedural Programming	Object-Oriented Programming
Approach	Functions & procedures	Objects & classes
Data Handling	Separate from functions	Encapsulated inside objects
Reusability	Limited	High (inheritance, polymorphism)
Security	Low	High (data hiding)
Maintenance	Difficult	Easier

4) What are the benefits of OOP?
Code reusability
Better maintainability
Modularity
Scalability
Improved security
Real-world modeling
Easier debugging and testing

5) What are the four main pillars of OOP?
The four pillars of OOP are:
Encapsulation
Abstraction
Inheritance
Polymorphism

6) Define Encapsulation
Encapsulation is the process of binding data and methods together and restricting direct access to the data.
üîπ Achieved using access modifiers (private, protected, public)
Example (Kotlin):
class User {
    private var password: String = "1234"

    fun getPassword(): String {
        return password
    }
}

7) Define Abstraction
Abstraction means hiding implementation details and exposing only the essential features.
üîπ Achieved using:
Abstract classes
Interfaces
Example:
interface Vehicle {
    fun start()
}

8) Define Inheritance
Inheritance allows a class to acquire properties and behaviors of another class, promoting code reuse.
üîπ Kotlin uses : for inheritance
Example:
open class Animal {
    fun sound() {
        println("Animal sound")
    }
}
class Dog : Animal()

9) Define Polymorphism
Polymorphism means one interface, multiple implementations.
Types:
Compile-time polymorphism (function overloading)
Runtime polymorphism (method overriding)
Example:
open class Shape {
    open fun draw() {
        println("Drawing shape")
    }
}
class Circle : Shape() {
    override fun draw() {
        println("Drawing circle")
    }
}

10) What is Compile-Time Polymorphism (Function Overloading)
Definition:
Compile-time polymorphism occurs when multiple functions have the same name but different parameter lists, and the method call is resolved at compile time.
Key Points:
Same method name
Different number, type, or order of parameters
No inheritance required
Faster execution (decision made at compile time)
Example (Kotlin):
class Calculator {
    fun add(a: Int, b: Int) = a + b
    fun add(a: Double, b: Double) = a + b
}
One-liner:
Compile-time polymorphism is achieved through function overloading, where method resolution happens during compilation.

11) What is Runtime Polymorphism (Method Overriding)
Definition:
Runtime polymorphism occurs when a child class overrides a method of its parent class, and the method call is resolved at runtime based on the object type.
Key Points:
Inheritance is required
Parent method must be open
Child method uses override
More flexible and dynamic
Example (Kotlin):
open class Animal {
    open fun sound() {
        println("Animal sound")
    }
}
class Dog : Animal() {
    override fun sound() {
        println("Dog barks")
    }
}
One-liner:
Runtime polymorphism allows method overriding, where the method call is decided at runtime based on the actual object.

12) Difference between Compile-Time and Runtime polymorphism
Quick Difference (Interview Favorite)
Compile-Time	            Runtime
Function overloading	    Method overriding
Resolved at compile time	Resolved at runtime
No inheritance needed	    Inheritance required
Less flexible	            More flexible

2. Variables & Types (Kotlin)

1) What is the difference between val and var in Kotlin? When would you use each?
val ‚Üí Immutable (read-only), value cannot be reassigned
var ‚Üí Mutable, value can be changed
When to use:
Use val by default for safety and clarity
Use var only when the value must change
Example:
val name = "Shreyas"
var age = 25
age = 26

2) What are the various data types available in Kotlin? Explain them.
Basic Data Types:
Int, Long, Short, Byte ‚Üí Integers
Float, Double ‚Üí Decimal numbers
Boolean ‚Üí true / false
Char ‚Üí Single character
String ‚Üí Text
Array ‚Üí Fixed-size collection
List, Set, Map ‚Üí Collections
Any ‚Üí Superclass of all non-null types
Unit ‚Üí Similar to void
Nothing ‚Üí Represents no value (used in exceptions)

3) Can primitive types like int, float, and double be used interchangeably with their Kotlin equivalents?
Yes, Kotlin handles this automatically.
Kotlin does not expose primitive types directly
It uses wrapper classes internally (Int, Double)
The compiler optimizes them to primitives when possible
Example:
val a: Int = 10
val b: Double = a.toDouble()
‚ö† Explicit conversion is required (toInt(), toDouble())

4) What is type inference in Kotlin?
Type inference allows the compiler to automatically determine the variable type based on the assigned value.
Example:
val number = 10      // Int inferred
val name = "Kotlin" // String inferred
Benefit: Less code, better readability

5) What is the const keyword in Kotlin? What are its advantages?
const is used to define compile-time constants.
Rules:
Must be val
Must be top-level or inside object
Only primitive types and String allowed
Example:
const val BASE_URL = "https://api.example.com"
Advantages:
Faster access (resolved at compile time)
Used in annotations
Improves performance and clarity

6) What is the difference between const and val?
Feature	                val	    const val
Compile-time constant	‚ùå	    ‚úÖ
Runtime initialization	‚úÖ	    ‚ùå
Allowed inside class	‚úÖ	    ‚ùå
Used in annotations	    ‚ùå	    ‚úÖ

7) What is the difference between val, var, and const in Kotlin?
Keyword	Mutability	Compile-time	Usage
val	Immutable	No	Read-only variable
var	Mutable	No	Changeable variable
const val	Immutable	Yes	Constants

8) Does Kotlin have a ternary operator like Java? If not, what is the alternative?
‚ùå Kotlin does not have a ternary operator.
‚úÖ Kotlin uses if as an expression.
Example:
val max = if (a > b) a else b
This is idiomatic, readable, and powerful.

3. Null Safety (Kotlin)

1) Explain the concept of Null Safety in Kotlin.
Null Safety in Kotlin is a feature that prevents NullPointerExceptions at compile time by distinguishing between nullable and non-nullable types.
By default, variables cannot hold null values unless explicitly allowed.

2) How does Kotlin prevent NullPointerExceptions?
Kotlin prevents NPEs by:
Making types non-nullable by default
Forcing explicit handling of nullable values
Providing operators like ?., ?:, let
Restricting unsafe calls at compile time

3) What are Nullable Types in Kotlin?
Nullable types are variables that can hold null values.
Example:
var name: String? = null
Without ?, assigning null causes a compile-time error.

4) How are Nullable Types denoted?
Nullable types are denoted using a question mark (?) after the type.
Example:
String?   // Nullable
String    // Non-nullable

5) What is the purpose of the safe call operator (?.)?
The safe call operator is used to call a method or access a property only if the object is not null.
If the object is null, it returns null instead of throwing an exception.
Example:
val length = name?.length

6) What is the Elvis Operator (?:) in Kotlin?
The Elvis operator provides a default value when an expression is null.
Example:
val length = name?.length ?: 0
If name is null, length becomes 0.

7) What is the difference between safe calls (?.) and null check (!!)?
Safe Call (?.)	Not-Null Assertion (!!)
Returns null if object is null	Throws NPE if object is null
Safe and recommended	Unsafe
Avoids crashes	Can crash app

8) What is the purpose of the Not-Null Assertion Operator (!!)?
!! tells the compiler ‚ÄúI am sure this value is not null‚Äù and forces a non-null value.
Example:
val length = name!!.length
If name is null ‚Üí NullPointerException

9) When should the Not-Null Assertion Operator be used cautiously?
Use !! only when:
You are 100% sure the value is never null
Interacting with legacy Java code
You want an immediate crash for invalid state (rare)
‚ö† Overuse can defeat Kotlin‚Äôs null safety

10) Explain the use of the requireNotNull function in Kotlin.
requireNotNull() is used to validate function arguments and throws an IllegalArgumentException if the value is null.
Example:
fun printName(name: String?) {
    requireNotNull(name) { "Name cannot be null" }
    println(name)
}
Advantages:
Cleaner than if (value == null)
Provides clear error messages
Preferred for parameter validation

# Kotlin Class and Object Interview Questions

## What is a class in Kotlin?
A class is a blueprint or template that defines the structure and behavior of objects. It encapsulates data (properties) and functions (methods) that operate on that data. A class defines what an object will look like and what it can do, but it doesn't represent the actual object itself.

## Explain class in Kotlin with example
```kotlin
class Car {
    // Properties
    var brand: String = ""
    var model: String = ""
    var year: Int = 0
    var color: String = ""
    // Methods
    fun startEngine() {
        println("$brand $model engine started!")
    }
    
    fun drive() {
        println("The $color $brand is driving")
    }
    
    fun displayInfo() {
        println("Car: $year $brand $model, Color: $color")
    }
}
In this example, `Car` is a class that defines properties like brand, model, year, and color, along with methods like startEngine(), drive(), and displayInfo().

## How does class act as a blueprint for objects?
A class acts as a blueprint by defining the template from which objects are created. Just like an architectural blueprint specifies how a building should be constructed, a class specifies what properties and behaviors its objects will have. When you create an object from a class, you're essentially creating a concrete instance based on that blueprint. Multiple objects can be created from the same class, each with its own unique property values but sharing the same structure and behavior defined in the class.

## What is an object in Kotlin?
An object is a concrete instance of a class. It's a real entity that exists in memory with actual values for the properties defined in the class. While a class is just a definition, an object is the actual implementation of that definition with specific data.

## Explain object in Kotlin with example
```kotlin
class Car {
    var brand: String = ""
    var model: String = ""
    var year: Int = 0
    var color: String = ""
    
    fun displayInfo() {
        println("Car: $year $brand $model, Color: $color")
    }
}

fun main() {
    // Creating objects (instances) of the Car class
    val car1 = Car()
    car1.brand = "Toyota"
    car1.model = "Camry"
    car1.year = 2023
    car1.color = "Blue"
    
    val car2 = Car()
    car2.brand = "Honda"
    car2.model = "Civic"
    car2.year = 2024
    car2.color = "Red"
    
    // Using the objects
    car1.displayInfo()  // Output: Car: 2023 Toyota Camry, Color: Blue
    car2.displayInfo()  // Output: Car: 2024 Honda Civic, Color: Red
}
Here, `car1` and `car2` are objects created from the `Car` class. Each has its own unique property values.

## How is object an instance of a class?
An object is an instance of a class because it's created based on the class definition. The class provides the structure, and the object is the actual realization of that structure with specific values. When you instantiate a class using the constructor (e.g., `Car()`), you allocate memory for a new object and initialize it according to the class blueprint. Each instance is independent and has its own copy of the properties defined in the class.

## What is the difference between a class and an object in Kotlin?
**Class:**
- A blueprint or template
- Doesn't occupy memory (until instantiated)
- Defines the structure and behavior
- Written once and can create multiple objects
- Abstract concept

**Object:**
- A concrete instance of a class
- Occupies memory
- Has actual values for properties
- Each object is independent
- Real entity that exists at runtime

```kotlin
// Class - blueprint
class Phone {
    var brand: String = ""
    var price: Double = 0.0
}

// Objects - actual instances
val phone1 = Phone()  // First instance
phone1.brand = "Samsung"
phone1.price = 799.99

val phone2 = Phone()  // Second instance
phone2.brand = "Apple"
phone2.price = 999.99

## Explain using a real-world analogy
**Cookie Cutter Analogy:**
Think of a class as a cookie cutter and objects as the actual cookies.
- **Class (Cookie Cutter):** The cookie cutter defines the shape and design of the cookie. It's reusable and defines what the cookies will look like, but you can't eat the cookie cutter itself. It's just a template.
- **Objects (Cookies):** When you use the cookie cutter on dough, you create actual cookies. Each cookie has the same shape (structure) defined by the cutter, but each cookie is a separate, independent entity. You can decorate them differently (different property values), eat them separately, and they exist independently from each other.
**House Blueprint Analogy:**
- **Class (Blueprint):** An architectural blueprint shows the design of a house with rooms, dimensions, and features. The blueprint itself isn't a house you can live in.
- **Objects (Houses):** Using the same blueprint, you can build multiple houses. Each house follows the same design, but they're separate physical structures. One house might be painted blue, another white. One might have different furniture than the other. They're independent instances built from the same blueprint.
This is exactly how classes and objects work in Kotlin‚Äîthe class is the plan, and objects are the real things created from that plan.

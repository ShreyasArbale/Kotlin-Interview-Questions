1. Fundamentals & Core Concepts

1.1 Basic Kotlin Concepts

1) What is Kotlin?
Kotlin is a modern, statically typed programming language that runs on the JVM and is officially supported by Google for Android development. It is concise, safe, and fully interoperable with Java.

2) Who developed Kotlin?
Kotlin was developed by JetBrains, the company behind IntelliJ IDEA and Android Studio.

3) What are the key advantages and features of Kotlin compared to Java?
Concise code (less boilerplate)
Null safety (reduces NullPointerException)
Full Java interoperability
Smart casts
Extension functions
Data classes
Coroutines for asynchronous programming
Improved readability and maintainability

4) What is the difference between Java and Kotlin?
Feature	                Java	    Kotlin
Null Safety	            No	        Yes
Boilerplate Code	    More	    Less
Data Classes	        Manual	    Built-in
Coroutines	            Not native	Built-in
Extension Functions	    No	        Yes
Checked Exceptions	    Yes	        No
Functional Support	    Limited	    Strong

5) What is Kotlin's primary target platform?
Kotlinâ€™s primary target platform is the Java Virtual Machine (JVM), but it also supports:
Android
Kotlin/JS (JavaScript)
Kotlin/Native (iOS, desktop, embedded)

6) How does Kotlin-Java interoperability work?
Kotlin can call Java code directly
Java can call Kotlin code
Kotlin compiles to JVM bytecode
Existing Java libraries and frameworks work seamlessly in Kotlin
No need to rewrite Java code when migrating

7) What programming paradigms does Kotlin support?
Kotlin supports:
Object-Oriented Programming (OOP)
Functional Programming
Procedural Programming
Declarative style (especially with Jetpack Compose)

8) What serves as the entry point for a Kotlin program?
The entry point is the main() function:
fun main() {
    println("Hello, Kotlin")
}

9) What are some basic syntax rules in Kotlin?
Semicolons are optional
fun keyword is used for functions
val for immutable variables, var for mutable
Type inference is supported
Classes are declared using class
String templates use $variable
Example:
val name = "Shreyas"
fun greet() {
    println("Hello $name")
}

10) What are some common libraries and frameworks used with Kotlin (beyond standard library)?
Android Jetpack (ViewModel, LiveData, Room)
Jetpack Compose
Kotlin Coroutines
Retrofit
Ktor
Firebase
Dagger / Hilt
Glide / Coil
JUnit / MockK

1.2 Object-Oriented Programming (OOP) Fundamentals

1) What is Object-Oriented Programming (OOP)?
Object-Oriented Programming is a programming paradigm that organizes software using objects, which represent real-world entities. Each object contains data (properties) and behavior (methods).

2) Explain the core concept of OOP.
The core concept of OOP is modeling real-world problems using objects that:
Combine data + behavior
Interact with each other
Promote reusability, scalability, and maintainability

3) How does OOP differ from procedural programming?
Aspect	Procedural Programming	Object-Oriented Programming
Approach	Functions & procedures	Objects & classes
Data Handling	Separate from functions	Encapsulated inside objects
Reusability	Limited	High (inheritance, polymorphism)
Security	Low	High (data hiding)
Maintenance	Difficult	Easier

4) What are the benefits of OOP?
Code reusability
Better maintainability
Modularity
Scalability
Improved security
Real-world modeling
Easier debugging and testing

5) What are the four main pillars of OOP?
The four pillars of OOP are:
Encapsulation
Abstraction
Inheritance
Polymorphism

6) Define Encapsulation
Encapsulation is the process of binding data and methods together and restricting direct access to the data.
ðŸ”¹ Achieved using access modifiers (private, protected, public)
Example (Kotlin):
class User {
    private var password: String = "1234"

    fun getPassword(): String {
        return password
    }
}

7) Define Abstraction
Abstraction means hiding implementation details and exposing only the essential features.
ðŸ”¹ Achieved using:
Abstract classes
Interfaces
Example:
interface Vehicle {
    fun start()
}

8) Define Inheritance
Inheritance allows a class to acquire properties and behaviors of another class, promoting code reuse.
ðŸ”¹ Kotlin uses : for inheritance
Example:
open class Animal {
    fun sound() {
        println("Animal sound")
    }
}
class Dog : Animal()

9) Define Polymorphism
Polymorphism means one interface, multiple implementations.
Types:
Compile-time polymorphism (function overloading)
Runtime polymorphism (method overriding)
Example:
open class Shape {
    open fun draw() {
        println("Drawing shape")
    }
}
class Circle : Shape() {
    override fun draw() {
        println("Drawing circle")
    }
}

10) What is Compile-Time Polymorphism (Function Overloading)
Definition:
Compile-time polymorphism occurs when multiple functions have the same name but different parameter lists, and the method call is resolved at compile time.
Key Points:
Same method name
Different number, type, or order of parameters
No inheritance required
Faster execution (decision made at compile time)
Example (Kotlin):
class Calculator {
    fun add(a: Int, b: Int) = a + b
    fun add(a: Double, b: Double) = a + b
}
One-liner:
Compile-time polymorphism is achieved through function overloading, where method resolution happens during compilation.

11) What is Runtime Polymorphism (Method Overriding)
Definition:
Runtime polymorphism occurs when a child class overrides a method of its parent class, and the method call is resolved at runtime based on the object type.
Key Points:
Inheritance is required
Parent method must be open
Child method uses override
More flexible and dynamic
Example (Kotlin):
open class Animal {
    open fun sound() {
        println("Animal sound")
    }
}
class Dog : Animal() {
    override fun sound() {
        println("Dog barks")
    }
}
One-liner:
Runtime polymorphism allows method overriding, where the method call is decided at runtime based on the actual object.

12) Difference between Compile-Time and Runtime polymorphism
Quick Difference (Interview Favorite)
Compile-Time	            Runtime
Function overloading	    Method overriding
Resolved at compile time	Resolved at runtime
No inheritance needed	    Inheritance required
Less flexible	            More flexible

2. Variables & Types (Kotlin)

1) What is the difference between val and var in Kotlin? When would you use each?
val â†’ Immutable (read-only), value cannot be reassigned
var â†’ Mutable, value can be changed
When to use:
Use val by default for safety and clarity
Use var only when the value must change
Example:
val name = "Shreyas"
var age = 25
age = 26

2) What are the various data types available in Kotlin? Explain them.
Basic Data Types:
Int, Long, Short, Byte â†’ Integers
Float, Double â†’ Decimal numbers
Boolean â†’ true / false
Char â†’ Single character
String â†’ Text
Array â†’ Fixed-size collection
List, Set, Map â†’ Collections
Any â†’ Superclass of all non-null types
Unit â†’ Similar to void
Nothing â†’ Represents no value (used in exceptions)

3) Can primitive types like int, float, and double be used interchangeably with their Kotlin equivalents?
Yes, Kotlin handles this automatically.
Kotlin does not expose primitive types directly
It uses wrapper classes internally (Int, Double)
The compiler optimizes them to primitives when possible
Example:
val a: Int = 10
val b: Double = a.toDouble()
âš  Explicit conversion is required (toInt(), toDouble())

4) What is type inference in Kotlin?
Type inference allows the compiler to automatically determine the variable type based on the assigned value.
Example:
val number = 10      // Int inferred
val name = "Kotlin" // String inferred
Benefit: Less code, better readability

5) What is the const keyword in Kotlin? What are its advantages?
const is used to define compile-time constants.
Rules:
Must be val
Must be top-level or inside object
Only primitive types and String allowed
Example:
const val BASE_URL = "https://api.example.com"
Advantages:
Faster access (resolved at compile time)
Used in annotations
Improves performance and clarity

6) What is the difference between const and val?
Feature	                val	    const val
Compile-time constant	âŒ	    âœ…
Runtime initialization	âœ…	    âŒ
Allowed inside class	âœ…	    âŒ
Used in annotations	    âŒ	    âœ…

7) What is the difference between val, var, and const in Kotlin?
Keyword	Mutability	Compile-time	Usage
val	Immutable	No	Read-only variable
var	Mutable	No	Changeable variable
const val	Immutable	Yes	Constants

8) Does Kotlin have a ternary operator like Java? If not, what is the alternative?
âŒ Kotlin does not have a ternary operator.
âœ… Kotlin uses if as an expression.
Example:
val max = if (a > b) a else b
This is idiomatic, readable, and powerful.

3. Null Safety (Kotlin)

1) Explain the concept of Null Safety in Kotlin.
Null Safety in Kotlin is a feature that prevents NullPointerExceptions at compile time by distinguishing between nullable and non-nullable types.
By default, variables cannot hold null values unless explicitly allowed.

2) How does Kotlin prevent NullPointerExceptions?
Kotlin prevents NPEs by:
Making types non-nullable by default
Forcing explicit handling of nullable values
Providing operators like ?., ?:, let
Restricting unsafe calls at compile time

3) What are Nullable Types in Kotlin?
Nullable types are variables that can hold null values.
Example:
var name: String? = null
Without ?, assigning null causes a compile-time error.

4) How are Nullable Types denoted?
Nullable types are denoted using a question mark (?) after the type.
Example:
String?   // Nullable
String    // Non-nullable

5) What is the purpose of the safe call operator (?.)?
The safe call operator is used to call a method or access a property only if the object is not null.
If the object is null, it returns null instead of throwing an exception.
Example:
val length = name?.length

6) What is the Elvis Operator (?:) in Kotlin?
The Elvis operator provides a default value when an expression is null.
Example:
val length = name?.length ?: 0
If name is null, length becomes 0.

7) What is the difference between safe calls (?.) and null check (!!)?
Safe Call (?.)	Not-Null Assertion (!!)
Returns null if object is null	Throws NPE if object is null
Safe and recommended	Unsafe
Avoids crashes	Can crash app

8) What is the purpose of the Not-Null Assertion Operator (!!)?
!! tells the compiler â€œI am sure this value is not nullâ€ and forces a non-null value.
Example:
val length = name!!.length
If name is null â†’ NullPointerException

9) When should the Not-Null Assertion Operator be used cautiously?
Use !! only when:
You are 100% sure the value is never null
Interacting with legacy Java code
You want an immediate crash for invalid state (rare)
âš  Overuse can defeat Kotlinâ€™s null safety

10) Explain the use of the requireNotNull function in Kotlin.
requireNotNull() is used to validate function arguments and throws an IllegalArgumentException if the value is null.
Example:
fun printName(name: String?) {
    requireNotNull(name) { "Name cannot be null" }
    println(name)
}
Advantages:
Cleaner than if (value == null)
Provides clear error messages
Preferred for parameter validation

4. Kotlin Class and Object

4.1 Basic Class and Object Concepts

1) What is a class in Kotlin?
A class in Kotlin is a blueprint or template that defines the structure and behavior of objects.
It encapsulates:
Properties â†’ to store data
Functions â†’ to define behavior
A class itself does not represent a real object; it only describes what an object will look like and what it can do.

2) Explain class in Kotlin with example
class Car {
    var brand: String = ""
    var model: String = ""
    var year: Int = 0
    var color: String = ""

    fun startEngine() {
        println("$brand $model engine started")
    }

    fun drive() {
        println("The $color $brand is driving")
    }

    fun displayInfo() {
        println("Car: $year $brand $model, Color: $color")
    }
}
Explanation:
Here, Car is a class that defines:
Properties like brand, model, year, and color
Methods like startEngine(), drive(), and displayInfo()
This class defines what a car object will contain and how it will behave.

3) How does a class act as a blueprint for objects?
A class acts as a blueprint because it defines:
The data structure of an object
The operations that can be performed on that data
From one class, we can create multiple objects, each having its own values but sharing the same structure and behavior.

4) What is an object in Kotlin?
An object is a real, concrete instance of a class.
It exists in memory at runtime and contains actual values for the properties defined in the class.

5) Explain object in Kotlin with example
fun main() {
    val car1 = Car()
    car1.brand = "Toyota"
    car1.model = "Camry"
    car1.year = 2023
    car1.color = "Blue"

    val car2 = Car()
    car2.brand = "Honda"
    car2.model = "Civic"
    car2.year = 2024
    car2.color = "Red"

    car1.displayInfo()
    car2.displayInfo()
}
Explanation:
car1 and car2 are objects of the Car class
Each object has its own state
Both follow the same structure defined by the class

6) How is an object an instance of a class?
An object is called an instance of a class because:
It is created using the class constructor
Memory is allocated at runtime
Properties are initialized with actual values
Each object is independent, even though it is created from the same class.

7) What is the difference between a class and an object in Kotlin?
Class:
Blueprint or template
Does not occupy memory
Defines properties and methods
Written once
Logical/abstract concept
Object:
Instance of a class
Occupies memory
Holds actual values
Can be multiple
Real entity at runtime
class Phone {
    var brand: String = ""
    var price: Double = 0.0
}
val phone1 = Phone()
val phone2 = Phone()

8) Explain using a real-world analogy
Cookie Cutter Analogy
Class: Cookie cutter â†’ defines the shape
Object: Cookies â†’ actual items created from the cutter
Each cookie looks similar but is a separate entity.
House Blueprint Analogy
Class: Blueprint of a house
Object: Actual houses built using the blueprint
All houses follow the same design but can differ in color, furniture, or location.

4.2 Special Types of Classes

1) What is a data class in Kotlin?
A data class in Kotlin is a special class used to hold data.
Its primary purpose is to store values, not to define complex behavior.
Kotlin automatically generates common boilerplate code for data classes, making them concise and readable.
Example
data class User(
    val id: Int,
    val name: String,
    val email: String
)

2) What boilerplate code do data classes generate?
For a data class, Kotlin automatically generates:
equals()
hashCode()
toString()
copy()
componentN() functions (for destructuring)
Example:
val user1 = User(1, "Alice", "alice@gmail.com")
val user2 = user1.copy(name = "Bob")

3) What are the benefits of data classes?
Reduces boilerplate code
Improves code readability
Provides immutability using val
Easy object comparison
Built-in copy functionality
Ideal for DTOs, API models, and database entities

4) How does Kotlin's data class support OOP principles?
Encapsulation: Properties are grouped inside a class
Abstraction: Exposes meaningful data models
Polymorphism: Can implement interfaces or extend classes
Immutability: Promotes safer object handling

5) Difference between data class and regular class
Data Class	Regular Class
Automatically generates boilerplate code	Manual implementation needed
Used mainly for holding data	Used for logic and behavior
Must have at least one parameter	No such restriction
Focus on state	Focus on behavior

6) What is an enum class in Kotlin?
An enum class represents a fixed set of constants.
Example
enum class Status {
    SUCCESS,
    ERROR,
    LOADING
}
Usage:
val status = Status.SUCCESS

7) What are sealed classes in Kotlin?
A sealed class restricts class inheritance to a fixed set of subclasses known at compile time.
sealed class Result {
    data class Success(val data: String) : Result()
    data class Error(val message: String) : Result()
}

8) What are sealed interfaces in Kotlin?
Sealed interfaces work like sealed classes but allow:
Multiple inheritance
Greater flexibility
sealed interface ApiResponse
class Success(val data: String) : ApiResponse
class Failure(val error: String) : ApiResponse

9) When are sealed classes useful (especially with when)?
Sealed classes are useful when:
You want exhaustive when expressions
All cases must be handled at compile time
fun handle(result: Result) {
    when (result) {
        is Result.Success -> println(result.data)
        is Result.Error -> println(result.message)
    }
}
No else is required.

10) Difference between sealed class and abstract class
Sealed Class	Abstract Class
Restricted inheritance	Open inheritance
Known subclasses	Unknown subclasses
Best for state modeling	Best for behavior
Exhaustive when	Requires else

11) How is sealed class useful for abstraction and polymorphism?
Abstraction: Defines a base type
Polymorphism: Different subclasses provide different implementations
Compile-time safety ensures all cases are handled

12) Benefits of using sealed class over enum
Can hold data
Supports inheritance
Can have complex state
Better modeling of UI states, API responses

13) What are value classes in Kotlin?
Value classes (inline classes) wrap a single value without runtime overhead.
@JvmInline
value class UserId(val id: Int)
Benefits:
Type safety
No extra object allocation
Performance optimized

14) Difference between nested and inner classes
Nested Class
Does not hold reference to outer class
Static by default
class Outer {
    class Nested {
        fun show() = "Nested"
    }
}
Inner Class
Holds reference to outer class
Uses inner keyword
class Outer {
    private val name = "Outer"

    inner class Inner {
        fun show() = name
    }
}

4.3 Generic Classes and Type System

1) What is a Generic Class?
A generic class allows you to define a class with type parameters, making it reusable and type-safe.
class Box<T>(val value: T)
Usage:
val intBox = Box(10)
val stringBox = Box("Hello")

2) What is typealias in Kotlin?
typealias creates an alternative name for an existing type.
typealias UserList = List<User>
Benefits:
Improves readability
Simplifies complex types

3) Explain the concepts of covariance, contravariance, and invariance in Kotlin generics. Provide examples.
Invariance (default)
class Box<T>
Box<Int> is NOT a subtype of Box<Number>
Covariance (out)
Used for producers
class Producer<out T>
Allows:
Producer<Int> â†’ Producer<Number>
Contravariance (in)
Used for consumers
class Consumer<in T>
Allows:
Consumer<Number> â†’ Consumer<Int>

4.4 Object Expressions and Declarations

1) What are object expressions and declarations?
Object Expression
Creates anonymous objects
val obj = object {
    val name = "Anonymous"
}
Object Declaration (Singleton)
Creates a single instance
object Database {
    fun connect() {}
}

2) Difference between object (singleton) and companion object
Object (Singleton)
Only one instance
Used globally
object Logger {
    fun log(msg: String) {}
}
Companion Object
Belongs to a class
Used for static-like members
class User {
    companion object {
        fun create(): User = User()
    }
}
